<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0275)http://www.javaworld.com/cgi-bin/mailto/x_java.cgi?pagetosend=/export/home/httpd/javaworld/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html&pagename=/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html&pageurl=http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html&site=jw_core -->
<HTML><HEAD><TITLE>http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="MSHTML 6.00.2900.6082" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff><FONT size=1>Sponsored by:</FONT><BR><A 
href="http://ad.doubleclick.net/jump/idg.us.nwf.jw_core/jw_printer;pos=top;sz=728x90;tile=1;ord=1303207547?"><IMG 
height=90 
src="http--www_javaworld_com-javaworld-jw-12-1999-jw-12-ssj-jspmvc_files/817-grey.gif" 
width=728 border=0></A> 
<P><IMG height=57 alt="From JavaWorld:" 
src="http--www_javaworld_com-javaworld-jw-12-1999-jw-12-ssj-jspmvc_files/javaworld-logo-wht-bg.gif" 
width=173><BR><BR><FONT size=-1>This story appeared on JavaWorld 
at<BR>http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html
<P></FONT><!--startindex--><A id=top name=top></A>
<H1>Understanding JavaServer Pages Model 2 architecture</H1>
<H3>Exploring the MVC design pattern</H3>
<P class=byline>By&nbsp;Govind Seshadri,&nbsp;JavaWorld.com,&nbsp;12/29/99</P><!--#include virtual="/includes/community/storytools_bar_top.html"--><!-- CONTENT GOES HERE--><!--#set var="pages" value="3" --><!--#include virtual="/cgi-bin/pgnav05.pl?pageof=yes&pages=${pages}&${compare}" --><!--#if expr="${compare} = /^page\=1$/ || ${compare} = /^page\=full/" -->Despite 
its relatively recent introduction, JavaServer Pages (JSP) technology is well on 
its way to becoming the preeminent Java technology for building applications 
that serve dynamic Web content. Java developers love JSP for myriad reasons. 
Some like the fact that it brings the "write once, run anywhere" paradigm to 
interactive Web pages; others appreciate the fact that it is fairly simple to 
learn and lets them wield Java as a server-side scripting language. But most 
concur on one thing -- the biggest advantage of using JSP is that it helps 
effectively separate presentation from content. In this article, I provide an 
in-depth look at how you can gain optimal separation of presentation from 
content by using the JSP Model 2 architecture. This model can also be seen as a 
server-side implementation of the popular Model-View-Controller (MVC) design 
pattern. Please note that you should be familiar with the basics of JSP and 
servlet programming before continuing on, as I do not address any syntax issues 
in this article.<BR><BR>
<DIV class=textbox>
<H4 class=textboxhead>Server-Side Java: Read the whole series!</H4><A 
href="http://www.jguru.com/"><IMG height=96 alt=jGuru hspace=4 src="" width=76 
align=right vspace=10 border=0 valign="TOP"></A> 
<UL class=noindent>
  <LI><A 
  href="http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-welcome.html">Welcome 
  to the server-side Java series</A> 
  <LI><A 
  href="http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-ejb1.html">Create 
  forward-compatible beans in EJB, Part 1</A> 
  <LI><A 
  href="http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html">Understanding 
  JavaServer Pages Model 2 Architecture</A> </LI></UL></DIV><BR><BR>
<H3>So, what's wrong with servlets?</H3>While JSP may be great for serving up 
dynamic Web content and separating content from presentation, some may still 
wonder why servlets should be cast aside for JSP. The utility of servlets is not 
in question. They are excellent for server-side processing, and, with their 
significant installed base, are here to stay. In fact, architecturally speaking, 
you can view JSP as a high-level abstraction of servlets that is implemented as 
an extension of the Servlet 2.1 API. Still, you shouldn't use servlets 
indiscriminately; they may not be appropriate for everyone. For instance, while 
page designers can easily write a JSP page using conventional HTML or XML tools, 
servlets are more suited for back-end developers because they are often written 
using an IDE -- a process that generally requires a higher level of programming 
expertise. When deploying servlets, even developers have to be careful and 
ensure that there is no tight coupling between presentation and content. You can 
usually do this by adding a third-party HTML wrapper package like 
<CODE>htmlKona</CODE> to the mix. But even this approach, though providing some 
flexibility with simple screen changes, still does not shield you from a change 
in the presentation format itself. For example, if your presentation changed 
from HTML to DHTML, you would still need to ensure that wrapper packages were 
compliant with the new format. In a worst-case scenario, if a wrapper package is 
not available, you may end up hardcoding the presentation within the dynamic 
content. So, what is the solution? As you shall soon see, one approach would be 
to use both JSP and servlet technologies for building application 
systems.<BR><BR>
<H3>Differing philosophies</H3>The early JSP specifications advocated two 
philosophical approaches for building applications using JSP technology. These 
approaches, termed the JSP Model 1 and Model 2 architectures, differ essentially 
in the location at which the bulk of the request processing was performed. In 
the Model 1 architecture, shown in Figure 1, the JSP page alone is responsible 
for processing the incoming request and replying back to the client. There is 
still separation of presentation from content, because all data access is 
performed using beans. Although the Model 1 architecture should be perfectly 
suitable for simple applications, it may not be desirable for complex 
implementations. Indiscriminate usage of this architecture usually leads to a 
significant amount of scriptlets or Java code embedded within the JSP page, 
especially if there is a significant amount of request processing to be 
performed. While this may not seem to be much of a problem for Java developers, 
it is certainly an issue if your JSP pages are created and maintained by 
designers -- which is usually the norm on large projects. Ultimately, it may 
even lead to an unclear definition of roles and allocation of responsibilities, 
causing easily avoidable project-management headaches.<BR><BR>
<CENTER>
<P class=first><IMG height=208 
src="http--www_javaworld_com-javaworld-jw-12-1999-jw-12-ssj-jspmvc_files/MODEL1_sml.gif" 
width=425></P>
<P><STRONG>Figure 1: JSP Model 1 architecture</STRONG></P></CENTER>
<P>The Model 2 architecture, shown in Figure 2, is a hybrid approach for serving 
dynamic content, since it combines the use of both servlets and JSP. It takes 
advantage of the predominant strengths of both technologies, using JSP to 
generate the presentation layer and servlets to perform process-intensive tasks. 
Here, the servlet acts as the <EM>controller</EM> and is in charge of the 
request processing and the creation of any beans or objects used by the JSP, as 
well as deciding, depending on the user's actions, which JSP page to forward the 
request to. Note particularly that there is no processing logic within the JSP 
page itself; it is simply responsible for retrieving any objects or beans that 
may have been previously created by the servlet, and extracting the dynamic 
content from that servlet for insertion within static templates. In my opinion, 
this approach typically results in the cleanest separation of presentation from 
content, leading to clear delineation of the roles and responsibilities of the 
developers and page designers on your programming team. In fact, the more 
complex your application, the greater the benefits of using the Model 2 
architecture should be. </P>
<CENTER>
<P><IMG height=208 
src="http--www_javaworld_com-javaworld-jw-12-1999-jw-12-ssj-jspmvc_files/MODEL2_sml.gif" 
width=425></P>
<P><STRONG>Figure 2: JSP Model 2 architecture</STRONG></P></CENTER>
<P>In order to clarify the concepts behind the Model 2 architecture, let's walk 
through a detailed implementation of it: a sample online music store called 
Music Without Borders. </P>
<H3>Understanding Music Without Borders</H3>The main <EM>view,</EM> or 
presentation, for our Music Without Borders online store is facilitated by the 
JSP page <CODE>EShop.jsp</CODE> (shown in Listing 1). You will notice that the 
page deals almost exclusively with presenting the main user interface of the 
application to the client, and performs no processing whatsoever -- an optimal 
JSP scenario. Also, notice that another JSP page, <CODE>Cart.jsp</CODE> (shown 
in Listing 2), is included within <CODE>EShop.jsp</CODE> via the directive 
<CODE>&lt;jsp:include page="Cart.jsp" flush="true" /&gt;</CODE>. <BR><BR>
<TABLE cellSpacing=1 cellPadding=7 border=1>
  <TBODY>
  <TR>
    <TH vAlign=top align=left>Listing 1:<BR>EShop.jsp </TH></TR>
  <TR align=top>
    <TD>
      <DIV id=codewrap>
      <DIV id=codewrap46><PRE>&lt;%@ page session="true" %&gt;
&lt;html&gt;
&lt;head&gt;
 &lt;title&gt;Music Without Borders&lt;/title&gt;
&lt;/head&gt;
&lt;body bgcolor="#33CCFF"&gt;
 &lt;font face="Times New Roman,Times" size="+3"&gt;
  Music Without Borders
 &lt;/font&gt;
 &lt;hr&gt;&lt;p&gt;
 &lt;center&gt;
 &lt;form name="shoppingForm" 
   action="/examples/servlet/ShoppingServlet" 
   method="POST"&gt;
 &lt;b&gt;CD:&lt;/b&gt; 
 &lt;select name=CD&gt;
  &lt;option&gt;Yuan | The Guo Brothers | China | 4.95&lt;/option&gt;
  &lt;option&gt;Drums of Passion | Babatunde Olatunji | Nigeria | 6.95&lt;/option&gt;
  &lt;option&gt;Kaira | Tounami Diabate| Mali | 6.95&lt;/option&gt;
  &lt;option&gt;The Lion is Loose | Eliades Ochoa | Cuba | 3.95&lt;/option&gt;
  &lt;option&gt;Dance the Devil Away | Outback | Australia | 4.95&lt;/option&gt;
  &lt;option&gt;Record of Changes | Samulnori | Korea | 2.95&lt;/option&gt;
  &lt;option&gt;Djelika | Tounami Diabate | Mali | 4.95&lt;/option&gt;
  &lt;option&gt;Rapture | Nusrat Fateh Ali Khan | Pakistan | 2.95&lt;/option&gt;
  &lt;option&gt;Cesaria Evora | Cesaria Evora | Cape Verde | 6.95&lt;/option&gt;
  &lt;option&gt;Ibuki | Kodo | Japan | 3.95&lt;/option&gt;
 &lt;/select&gt;
 &lt;b&gt;Quantity: &lt;/b&gt;&lt;input type="text" name="qty" SIZE="3" value=1&gt;
 &lt;input type="hidden" name="action" value="ADD"&gt;
 &lt;input type="submit" name="Submit" value="Add to Cart"&gt;
 &lt;/form&gt;
 &lt;/center&gt;
 &lt;p&gt;
 &lt;jsp:include page="Cart.jsp" flush="true" /&gt;
&lt;/body&gt;
&lt;/html&gt;
</PRE></DIV></DIV></TD></TR></TBODY></TABLE><BR><BR>
<TABLE cellSpacing=1 cellPadding=7 border=1>
  <TBODY>
  <TR>
    <TH vAlign=top align=left>Listing 2:<BR>Cart.jsp </TH></TR>
  <TR align=top>
    <TD>
      <DIV id=codewrap>
      <DIV id=codewrap55><PRE>&lt;%@ page session="true" import="java.util.*, shopping.CD" %&gt;
&lt;%
 Vector buylist = (Vector) session.getValue("shopping.shoppingcart");
 if (buylist != null &amp;&amp; (buylist.size() &gt; 0)) {
%&gt;
&lt;center&gt;
&lt;table border="0" cellpadding="0" width="100%" bgcolor="#FFFFFF"&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;b&gt;ALBUM&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;ARTIST&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;COUNTRY&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;PRICE&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;QUANTITY&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;%
  for (int index=0; index &lt; buylist.size();index++) {
   CD anOrder = (CD) buylist.elementAt(index);
 %&gt;
 &lt;tr&gt;
  &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getAlbum() %&gt;&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getArtist() %&gt;&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getCountry() %&gt;&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getPrice() %&gt;&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getQuantity() %&gt;&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;
   &lt;form name="deleteForm"
    action="/examples/servlet/ShoppingServlet"
    method="POST"&gt;
   &lt;input type="submit" value="Delete"&gt;
   &lt;input type="hidden" name= "delindex" value='&lt;%= index %&gt;'&gt;
   &lt;input type="hidden" name="action" value="DELETE"&gt;
  &lt;/form&gt; 
      &lt;/td&gt;
    &lt;/tr&gt; 
    &lt;% } %&gt;
  &lt;/table&gt;
  &lt;p&gt;
  &lt;form name="checkoutForm"
    action="/examples/servlet/ShoppingServlet"
    method="POST"&gt;
    &lt;input type="hidden" name="action" value="CHECKOUT"&gt;
    &lt;input type="submit" name="Checkout" value="Checkout"&gt;
  &lt;/form&gt;
  &lt;/center&gt;
&lt;% } %&gt;
</PRE></DIV></DIV></TD></TR></TBODY></TABLE><BR><BR>
<P>Here, <CODE>Cart.jsp</CODE> handles the presentation of the session-based 
shopping cart, which constitutes the <EM>model</EM> in our MVC architecture. 
Observe the scriptlet at the beginning of <CODE>Cart.jsp</CODE>: </P>
<DIV id=codewrap>
<DIV id=codewrap65><PRE>&lt;%
  Vector buylist = (Vector) session.getValue("shopping.shoppingcart");
  if (buylist != null &amp;&amp; (buylist.size() &gt; 0)) {
%&gt;
</PRE></DIV></DIV><BR><BR>
<P>Basically, the scriptlet extracts the shopping cart from the session. If the 
cart is empty or not yet created, it displays nothing; thus, the first time a 
user accesses the application, she is presented with the view shown in Figure 3. 
</P>
<CENTER>
<P><IMG height=373 
src="http--www_javaworld_com-javaworld-jw-12-1999-jw-12-ssj-jspmvc_files/SSJFIG1.gif" 
width=500></P>
<P><STRONG>Figure 3: Music Without Borders, main view</STRONG></P></CENTER>
<P>If the shopping cart is not empty, then the selected items are extracted from 
the cart one at a time, as demonstrated by the following scriptlet: </P>
<DIV id=codewrap>
<DIV id=codewrap75><PRE>&lt;%
  for (int index=0; index &lt; buylist.size(); index++) {
    CD anOrder = (CD) buylist.elementAt(index);
%&gt;
</PRE></DIV></DIV><BR><BR>
<P>Once the variables describing an item have been created, they are then simply 
inserted into the static HTML template using JSP expressions. Figure 4 shows the 
application view after the user has placed some items in the shopping cart. </P>
<CENTER>
<P><IMG height=373 
src="http--www_javaworld_com-javaworld-jw-12-1999-jw-12-ssj-jspmvc_files/SSJFIG2.gif" 
width=500></P>
<P><STRONG>Figure 4: Music Without Borders, shopping cart 
view</STRONG></P></CENTER>
<P>The important thing to observe here is that the processing for all actions 
carried out within either <CODE>Eshop.jsp</CODE> or <CODE>Cart.jsp</CODE> is 
handled by the <EM>controller</EM> servlet, <CODE>ShoppingServlet.java</CODE>, 
which is shown in Listing 3. </P>
<TABLE cellSpacing=1 cellPadding=7 border=1>
  <TBODY>
  <TR>
    <TH vAlign=top align=left>Listing 3:<BR>ShoppingServlet.java </TH></TR>
  <TR>
    <TD>
      <DIV id=codewrap>
      <DIV id=codewrap92><PRE>import java.util.*;
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
import shopping.CD;
public class ShoppingServlet extends HttpServlet {
  public void init(ServletConfig conf) throws ServletException  {
    super.init(conf);
  }
  public void doPost (HttpServletRequest req, HttpServletResponse res)
      throws ServletException, IOException {
    HttpSession session = req.getSession(false);
    if (session == null) {
      res.sendRedirect("http://localhost:8080/error.html");
    }
    Vector buylist=
      (Vector)session.getValue("shopping.shoppingcart");
    String action = req.getParameter("action");
    if (!action.equals("CHECKOUT")) {
      if (action.equals("DELETE")) {
        String del = req.getParameter("delindex");
        int d = (new Integer(del)).intValue();
        buylist.removeElementAt(d);
      } else if (action.equals("ADD")) {
        //any previous buys of same cd?
        boolean match=false;
        CD aCD = getCD(req);
        if (buylist==null) {
          //add first cd to the cart
          buylist = new Vector(); //first order
          buylist.addElement(aCD);
        } else { // not first buy
          for (int i=0; i&lt; buylist.size(); i++) {
            CD cd = (CD) buylist.elementAt(i);
            if (cd.getAlbum().equals(aCD.getAlbum())) {
              cd.setQuantity(cd.getQuantity()+aCD.getQuantity());
              buylist.setElementAt(cd,i);
              match = true;
            } //end of if name matches
          } // end of for
          if (!match) 
            buylist.addElement(aCD);
        }
      }
      session.putValue("shopping.shoppingcart", buylist);
      String url="/jsp/shopping/EShop.jsp";
      ServletContext sc = getServletContext();
      RequestDispatcher rd = sc.getRequestDispatcher(url);
      rd.forward(req, res);
    } else if (action.equals("CHECKOUT"))  {
      float total =0;
      for (int i=0; i&lt; buylist.size();i++) {
        CD anOrder = (CD) buylist.elementAt(i);
        float price= anOrder.getPrice();
        int qty = anOrder.getQuantity();
        total += (price * qty);
      }
      total += 0.005;
      String amount = new Float(total).toString();
      int n = amount.indexOf('.');
      amount = amount.substring(0,n+3);
      req.setAttribute("amount",amount);
      String url="/jsp/shopping/Checkout.jsp";
      ServletContext sc = getServletContext();
      RequestDispatcher rd = sc.getRequestDispatcher(url);
      rd.forward(req,res);
    }
  }
  private CD getCD(HttpServletRequest req) {
    //imagine if all this was in a scriptlet...ugly, eh?
    String myCd = req.getParameter("CD");
    String qty = req.getParameter("qty");
    StringTokenizer t = new StringTokenizer(myCd,"|");
    String album= t.nextToken();
    String artist = t.nextToken();
    String country = t.nextToken();
    String price = t.nextToken();
    price = price.replace('$',' ').trim();
    CD cd = new CD();
    cd.setAlbum(album);
    cd.setArtist(artist);
    cd.setCountry(country);
    cd.setPrice((new Float(price)).floatValue());
    cd.setQuantity((new Integer(qty)).intValue());
    return cd;
  }
}
</PRE></DIV></DIV></TD></TR></TBODY></TABLE><BR><BR>
<P>Every time the user adds an item within <CODE>EShop.jsp</CODE>, the request 
is posted to the controller servlet. The servlet in turn determines the 
appropriate action, and then processes the request parameters for the item to be 
added. It then instantiates a new CD bean (shown in Listing 4) representing the 
selection, and goes about updating the shopping cart object before placing it 
back within the session. <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"--></P><!--#endif --><!--#if expr="${compare} = /^page\=2$/ || ${compare} = /^page\=full/" -->
<TABLE cellSpacing=1 cellPadding=7 border=1>
  <TBODY>
  <TR>
    <TH vAlign=top align=left>Listing 4:<BR>CD.java </TH></TR>
  <TR>
    <TD>
      <DIV id=codewrap>
      <DIV id=codewrap103><PRE>package shopping;
public class CD {
  String album;
  String artist;
  String country;
  float price;
  int quantity;
  public CD() {
    album="";
    artist="";
    country="";
    price=0;
    quantity=0;
  }
  public void setAlbum(String title) {
    album=title;
  }
  public String getAlbum() {
    return album;
  }
  public void setArtist(String group) {
    artist=group;
  }
  public String getArtist() {
    return artist;
  }
  public void setCountry(String cty) {
    country=cty;
  }
  public String getCountry() {
    return country;
  }
  public void setPrice(float p) {
    price=p;
  }
  public float getPrice() {
    return price;
  }
  public void setQuantity(int q) {
    quantity=q;
  }
  public int getQuantity() {
    return quantity;
  }
}
</PRE></DIV></DIV></TD></TR></TBODY></TABLE><BR><BR>
<P>Notice that we have also included additional intelligence within the servlet, 
so that it understands that, if a previously added CD is reselected, it should 
simply increase the count for that CD bean within the shopping cart. The 
controller servlet also processes actions triggered from within 
<CODE>Cart.jsp</CODE>, such as the user deleting items from the shopping cart, 
or proceeding to the checkout counter. Observe that the controller always has 
complete control over which resources should be invoked in response to specific 
actions. For example, changes made to the state of the shopping cart, such as 
additions or deletions, cause the controller servlet to forward the request 
after processing to the <CODE>Eshop.jsp</CODE> page. This in turn causes the 
page to redisplay the main view, along with the updated contents of the shopping 
cart. If the user decides to check out, the request is forwarded after 
processing to the <CODE>Checkout.jsp</CODE> page (shown in Listing 5) by means 
of the following request dispatcher, as shown below: </P>
<DIV id=codewrap>
<DIV id=codewrap113><PRE>String url="/jsp/shopping/Checkout.jsp";
ServletContext sc = getServletContext();
RequestDispatcher rd = sc.getRequestDispatcher(url);
rd.forward(req,res);
</PRE></DIV></DIV><BR><BR>
<TABLE cellSpacing=1 cellPadding=7 border=1>
  <TBODY>
  <TR>
    <TH vAlign=top align=left>Listing 5:<BR>Checkout.jsp </TH></TR>
  <TR>
    <TD>
      <DIV id=codewrap>
      <DIV id=codewrap119><PRE>&lt;%@ page session="true" import="java.util.*, shopping.CD" %&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Music Without Borders Checkout&lt;/title&gt;
&lt;/head&gt;
&lt;body bgcolor="#33CCFF"&gt;
 &lt;font face="Times New Roman,Times" size=+3&gt;
  Music Without Borders Checkout
 &lt;/font&gt;
 &lt;hr&gt;&lt;p&gt;
 &lt;center&gt;
 &lt;table border="0" cellpadding="0" width="100%" bgcolor="#FFFFFF"&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;b&gt;ALBUM&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;ARTIST&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;COUNTRY&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;PRICE&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;QUANTITY&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;%
  Vector buylist = (Vector) session.getValue("shopping.shoppingcart");
  String amount = (String) request.getAttribute("amount");
  for (int i=0; i &lt; buylist.size();i++) {
   CD anOrder = (CD) buylist.elementAt(i);
 %&gt;
 &lt;tr&gt;
 &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getAlbum() %&gt;&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getArtist() %&gt;&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getCountry() %&gt;&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getPrice() %&gt;&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;&lt;%= anOrder.getQuantity() %&gt;&lt;/b&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;%
  }
  session.invalidate();
 %&gt;
 &lt;tr&gt;
 &lt;td&gt;     &lt;/td&gt;
 &lt;td&gt;     &lt;/td&gt;
 &lt;td&gt;&lt;b&gt;TOTAL&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;&lt;b&gt;$&lt;%= amount %&gt;&lt;/b&gt;&lt;/td&gt;
 &lt;td&gt;     &lt;/td&gt;
 &lt;/tr&gt;
 &lt;/table&gt;
 &lt;p&gt;
 &lt;a href="/examples/jsp/shopping/EShop.jsp"&gt;Shop some more!&lt;/a&gt;
 &lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</PRE></DIV></DIV></TD></TR></TBODY></TABLE><BR><BR>
<P><CODE>Checkout.jsp</CODE> simply extracts the shopping cart from the session 
and the total amount for the request, and then displays the selected items and 
their total cost. Figure 5 shows the client view upon checkout. Once the user 
goes to the checkout counter, it is equally important to get rid of the session 
object. That is taken care of by having a <CODE>session.invalidate()</CODE> 
invocation at the end of the page. This process is necessary for two reasons. 
First, if the session is not invalidated, the user's shopping cart is not 
reinitialized; if the user then attempts to commence another round of shopping 
upon checkout, her shopping cart will continue to hold items that she has 
already purchased. The second reason is that if the user simply left the site 
upon checkout, the session object will not be garbage collected and will 
continue to take up valuable system resources until its lease period expires. 
Since the default session-lease period is about 30 minutes, this can quickly 
lead to the system running out of memory in a high-volume system. Of course, we 
all know what happens to an application that runs out of system resources! <!--#include virtual="/cgi-bin/pgnav.pl?cont=yes&pages=${pages}&${compare}"--></P><!--#if expr="${compare} != /^page\=full/" --><!--#endif --><!--#endif --><!--#if expr="${compare} = /^page\=3$/ || ${compare} = /^page\=full/" -->
<CENTER>
<P><IMG height=315 
src="http--www_javaworld_com-javaworld-jw-12-1999-jw-12-ssj-jspmvc_files/jw-12-ssjfig3_sml.gif" 
width=425></P>
<P><STRONG>Figure 5: Music Without Borders, checkout view</STRONG></P><!--#if expr="${compare} != /^page\=full/" --><!--#endif --></CENTER>
<P>Notice that all the resources for this application are session aware, since 
the model here is stored within the session. Consequently, you must ensure that 
the user does not somehow access the controller directly, even by mistake. You 
can take care of this by implementing the automatic client redirection to the 
error page (shown in Listing 6) when the controller detects the absence of a 
valid session. </P>
<H3>About the author</H3>Govind Seshadri is an Enterprise Java Guru for 
jGuru.com, and the author of Enterprise Java Computing -- Applications and 
Architecture from Cambridge University Press (1999). Learn more about Govind at 
jGuru.com. JavaWorld and jGuru have formed a partnership to help the community 
better understand server-side Java technology. Together, JavaWorld and jGuru are 
jointly producing articles, free educational Web events, and working together on 
the JavaWorld bookstore and Web-based training. 
<P><A href="http://www.javaworld.com/channel_content/jw-core-index.html" 
target=blank>Read more about Core Java</A> in JavaWorld's Core Java section. 
</P>
<TABLE cellSpacing=1 cellPadding=7 border=1>
  <TBODY>
  <TR>
    <TH vAlign=top align=left>Listing 6:<BR>error.html </TH></TR>
  <TR>
    <TD>
      <DIV id=codewrap>
      <DIV id=codewrap137><PRE>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;
  Sorry, there was an unrecoverable error! &lt;br&gt;
  Please try &lt;a href="/examples/jsp/shopping/EShop.jsp"&gt;again&lt;/a&gt;.
&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</PRE></DIV></DIV></TD></TR></TBODY></TABLE><BR><BR>
<H3>Deploying Music Without Borders</H3>I will assume that you are using the 
latest version of JavaServer Web Development Kit (JSWDK) from Sun for running 
the example. If not, see the <A 
href="http://www.javaworld.com/javaworld/jw-12-1999/jw-12-ssj-jspmvc.html#resources">Resources</A> 
section to find out where to get it. Assuming that the server is installed in 
<CODE>\jswdk-1.0.1</CODE>, its default location in Microsoft Windows, deploy the 
Music Without Borders application files as follows:<BR><BR>
<UL>
  <LI>Create shopping directory under <CODE>\jswdk-1.0.1\examples\jsp</CODE> 
  <LI>Copy <CODE>EShop.jsp</CODE> to 
  <CODE>\jswdk-1.0.1\examples\jsp\shopping</CODE> 
  <LI>Copy <CODE>Cart.jsp</CODE> to 
  <CODE>\jswdk-1.0.1\examples\jsp\shopping</CODE> 
  <LI>Copy <CODE>Checkout.jsp</CODE> to 
  <CODE>\jswdk-1.0.1\examples\jsp\shopping</CODE> 
  <LI>Compile the <CODE>.java</CODE> files by typing <CODE>javac *.java</CODE> 
  <LI>Copy <CODE>ShoppingServlet.class</CODE> to 
  <CODE>\jswdk-1.0.1\webpages\Web-Inf\servlets</CODE> 
  <LI>Create shopping directory under 
  <CODE>\jswdk-1.0.1\examples\Web-Inf\jsp\beans</CODE> 
  <LI>Copy <CODE>CD.class</CODE> to 
  <CODE>\jswdk-1.0.1\examples\Web-Inf\jsp\beans\shopping</CODE> 
  <LI>Copy <CODE>error.html</CODE> to <CODE>\jswdk-1.0.1\webpages</CODE> 
  <LI>Once your server has been started, you should be able to access the 
  application using <A 
  href="http://localhost:8080/examples/jsp/shopping/EShop.jsp">http://localhost:8080/examples/jsp/shopping/EShop.jsp</A> 
  as the URL </LI></UL><BR><BR>
<H3>Leveraging JSP and servlets</H3>In this example, we have examined in detail 
the level of control and flexibility provided by the Model 2 architecture. In 
particular, we've seen how the best features of servlets and JSP pages can be 
exploited to maximize the separation of presentation from content. Properly 
applied, the Model 2 architecture should result in the concentration of all of 
the processing logic in the hands of the controller servlet, with the JSP pages 
responsible only for the view or presentation. However, the downside of using 
the Model 2 approach is its complexity. Consequently, it may be desirable to use 
the Model 1 approach for simpler applications.<BR><BR><!--#endif --><!--#include virtual="/includes/global-pgnav.html" -->
<P><FONT size=-1>All contents copyright 1995-2011 Java World, Inc. <A 
href="http://www.javaworld.com/">http://www.javaworld.com/</A></FONT> 
</P></BODY></HTML>
